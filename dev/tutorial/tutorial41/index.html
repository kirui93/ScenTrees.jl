<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kernel Density Estimation · ScenTrees.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ScenTrees.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ScenTrees.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial1/">Introduction</a></li><li><a class="tocitem" href="../tutorial2/">Scenario Trees</a></li><li><a class="tocitem" href="../tutorial3/">Scenario Lattices</a></li><li><a class="tocitem" href="../tutorial31/">Stochastic processes</a></li><li><a class="tocitem" href="../tutorial4/">Stochastic approximation process</a></li><li class="is-active"><a class="tocitem" href>Kernel Density Estimation</a><ul class="internal"><li><a class="tocitem" href="#Implementation-of-the-above-process"><span>Implementation of the above process</span></a></li></ul></li><li><a class="tocitem" href="../tutorial5/">Performance of <code>ScenTrees.jl</code></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Kernel Density Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kernel Density Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kirui93/ScenTrees.jl/blob/master/docs/src/tutorial/tutorial41.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Kernel-Density-Estimation"><a class="docs-heading-anchor" href="#Kernel-Density-Estimation">Kernel Density Estimation</a><a id="Kernel-Density-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-Density-Estimation" title="Permalink"></a></h1><p>This is a non-parametric technique for generating trajectories used to generate and improve scenario trees and scenario lattices in the stochastic approximation algorithm already discussed in the previous tutorials. This is a case where the distributions are not available explicitly and so the samples can be drawn from a data by proper approximations. Generating a scenario tree/lattice using trajectories from these method involves two steps:</p><ol><li>Conditional density estimation process, and,</li><li>Stochastic approximation process.</li></ol><p>The stochastic approximation process has already been described in the previous tutorials. Hence, here we will concentrate on the conditional density estimation process.</p><p>The conditional density estimation step involves two steps:</p><ol><li>Estimation of the distribution of conditional densities, and,</li><li>Composition method</li></ol><p>We estimate the distribution of transition densities given the history of the process. This distribution is estimated by the non-parametric kernel density estimation. The density at stage <span>$t+1$</span> conditional on the history <span>$\mathbf{x_{t}} = (x_1,x_2,\ldots,x_t)$</span> is estimated by</p><p class="math-container">\[\hat{f}_{t+1}(x_{t+1}|\mathbf{x_{t}}) = \sum_{j=1}^{N} w_j(\mathbf{x_{t}}) \cdot k_{h_N}(x_{t+1} - \xi_{j,t+1}),\]</p><p>where <span>$k(.)$</span> is a kernel function, <span>$h_N$</span> is the bandwidth and <span>$k_{h_N}$</span> is the weighted kernel function.</p><p>The weights are given by</p><p class="math-container">\[w_j(\mathbf{x_{t}}) = \frac{k\big(\frac{x_{i_1} - \xi_{j,1}}{h_N}\big)\cdot \ldots \cdot k\big(\frac{x_{i_t} - \xi_{j,t}}{h_N}\big)}{\sum_{\ell=1}^{N}k\big(\frac{x_{i_1} - \xi_{l,1}}{h_N}\big)\cdot \ldots \cdot k\big(\frac{x_{i_t} - \xi_{l,t}}{h_N}\big)}.\]</p><p>Notice from above that the weights depend on the history <span>$\mathbf{x_{t}}$</span> up to stage <span>$t$</span> only. Also, the weights sum up to 1 for every <span>$\mathbf{x_{t}}$, i.e., $\sum_{j=1}^{N} w_j(\mathbf{x_{t}}) = 1$</span>.</p><p>We use the composition method to find the samples from the conditional distribution <span>$\hat{f}_{t+1}(.|\mathbf{x_{t}})$</span> as follows. Pick a random number <span>$u \in (0,1)$</span> where <span>$u$</span> is uniformly distributed then find a summation index <span>$j^{\star} \in {1,2,\ldots,N}$</span> such that <span>$\sum_{j=1}^{j^{\star}-1} w_j(\mathbf{x_{t}}) &lt; U \leq \sum_{j=1}^{j^{\star}} w_j(\mathbf{x_{t}}).$</span></p><p>It has been shown that the cumulative sum of weights leads to a high probability of picking a data path near the observation.</p><p>The value of the data <span>$\xi_t$</span> is obtained by setting the value at stage <span>$t$</span> to</p><p class="math-container">\[\xi_t = X_{j^{\star}} + h_N \times \text{rand}(k())\]</p><p>where <span>$\text{rand}(k())$</span> is a random value sampled from the kernel estimator.</p><p>The generated data point is according to the distribution of the density at the current stage and dependent on the history of all the data points. It has been shown that the choice of the kernel does not have an important effect on density estimation. Hence, we employ the following logistic kernel as default: <span>$k(x) = \frac{1}{(e^x + e^{-x})^2}.$</span></p><p>One of the most important factor to consider in density estimation is the bandwidth. We use the Silverman&#39;s rule of thumb to obtain the bandwidths for each of the data columns as follows <span>$h_N = \sigma(X_t)\cdot N^{\frac{-1}{d+4}}$</span> where <span>$d$</span> is dimension of values sitting on each node at stage <span>$t$</span> and <span>$\sigma(X_t)$</span> is the standard deviation of data in stage <span>$t$</span>.</p><p>Using the above procedure, every new sample path starts with <span>$x_1$</span> at the first stage. Using the composition method, we find a new sample <span>$x_2$</span> from <span>$\hat{f}_2(.|x_1)$</span> at the second stage. Next, we generate a new data point <span>$x_3$</span> from <span>$\hat{f}_3(.|x_{1:2})$</span>  at the third stage, a new sample <span>$x_t$</span> from <span>$\hat{f}_t(.|x_{1:t-1})$</span> at stage <span>$t$</span> e.t.c. Iterating the procedure until the stage <span>$T$</span> reveals a new sample path <span>$x = (x_1,x_2,\ldots,x_T)$</span>, generated from the initial data <span>$\xi_1,\ldots,\xi_N$</span> directly.</p><p>The new sample path <span>$x$</span> is what we will feed in the stochastic approximation algorithm to generate either a scenario tree or a scenario lattice.</p><h2 id="Implementation-of-the-above-process"><a class="docs-heading-anchor" href="#Implementation-of-the-above-process">Implementation of the above process</a><a id="Implementation-of-the-above-process-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-the-above-process" title="Permalink"></a></h2><p>We use the concept of function closures to implement the above process. The motive to use function closures is because we want to follow the guidelines of the package where the process function should be coded in such a way that it doesn&#39;t take any inputs. We assume that the user of this package is conversant with function closures. The user is required to provide a data in 2 dimension, i.e., a matrix of <code>Float64</code> or <code>Int64</code>, to this function and also the distribution of the kernel that he/she wants to use. The default kernel distribution is the Logistic kernel. The kernel distribution should conform to the distributions stated in <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a> package.</p><p>Most of the times when you load the data into Julia, it loads it as a <code>DataFrame</code> type. But we have wrote the function in a manner that the user should provide a Matrix of either floats or integers. In the following procedure, we use the function <code>Matrix</code> to convert the loaded dataframe into a matrix which is the right type of input into the function.</p><p>The function <code>kernel_scenarios(data::Union{Array{Int64,2},Array{Float64,2}}, kernelDistribution = Logistic; Markovian = true)</code> takes a <span>$(N \times T)$</span> dimensional data and the distribution of the kernel you want to employ. The <span>$N$</span> rows of the data are the number of trajectories in the initial data and the <span>$T$</span> columns is the number of stages in in each trajectory of the data. We also let the user to specify whether the process he/she is creating is a Markovian process or not. We are aware that scenario lattices are natural discretization of Markovian process. Hence the user should create samples for a scenario tree for the condition <code>Markovian = false</code> and scenario lattices for the condition <code>Markovian = true</code>.</p><p>Since <code>tree_approximation!</code> and <code>lattice_approximation</code> function needs a process function for generating samples that doesn&#39;t take any inputs, we employ the concept of function closures inside the above function. The function <code>kernel_scenarios(data, kernelDistribution; Markovian = true)</code> is a get-field type of a function closure and so is sufficient to be a function required for stochastic approximation process.</p><p>To confirm the above statement, consider a <span>$1000 \times 5$</span> dimensional data from random walk. What is important to be said is that we use the package <a href="https://github.com/JuliaData/CSV.jl"><code>CSV</code>.jl</a> to read the data into Julia and since we need the data in matrix form, we use the function <code>Matrix</code> from the package <a href="https://github.com/JuliaData/DataFrames.jl"><code>DataFrames.jl</code></a> to convert the dataframe into an array in two dimension which is then the input of our function.</p><pre><code class="language-julia hljs">julia&gt; using ScenTrees, CSV, Distributions
julia&gt; data = CSV.read(&quot;.../RandomDataWalk.csv&quot;)
julia&gt; Rdw = Matrix(data)
julia&gt; Kdt = kernel_scenarios(Rwd,Logistic;Markovian=true)
(::getfield(ScenTrees,Symbol(&quot;#closure#52&quot;)){Array{Float64,2},
Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1}})
(generic function with 1 method)
julia&gt; ExampleTraj = kernel_scenarios(Rwd, Logistic; Markovian = true)()
[2.9313, -2.0964, 3.7671, 2.1476, 0.9424]</code></pre><p>As in <code>ExampleTraj</code> above, this function returns is a new sample according to the distribution of the density at the current stage and dependent on the history of all the data points.</p><p>We use the above data to approximate a scenario lattice in <code>5</code> stages with a branching structure of <span>$(1\times 3\times 4\times 5\times6)$</span>  and <span>$100,000$</span> number of iterations as follows:</p><h3 id="Approximating-with-a-scenario-lattice"><a class="docs-heading-anchor" href="#Approximating-with-a-scenario-lattice">Approximating with a scenario lattice</a><a id="Approximating-with-a-scenario-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Approximating-with-a-scenario-lattice" title="Permalink"></a></h3><p>Using the above data, the conditional density estimation method and lattice approximation process we can generate a scenario lattice with a branching structure <code>[1,3,4,5,6]</code> and <code>100,000</code> iterations as follows.</p><pre><code class="language-julia hljs">julia&gt; KernExample = lattice_approximation([1,3,4,5,6],
kernel_scenarios(Rwd, Logistic; Markovian = true), 100000, 2, 1);
julia&gt; plot_lattice(KernExample)</code></pre><p>The following is the resultant lattice from the above approximation. The algorithm returns the multistage distance of the scenario lattice as <code>dist = 1.1718</code>.</p><p><img src="../../assets/KernLattice.png" alt="Scenario Lattice From Kernel Trajectories"/></p><h3 id="Approximating-with-a-scenario-tree"><a class="docs-heading-anchor" href="#Approximating-with-a-scenario-tree">Approximating with a scenario tree</a><a id="Approximating-with-a-scenario-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Approximating-with-a-scenario-tree" title="Permalink"></a></h3><p>Using the same procedure, we can generate a binary scenario tree with <code>100,000</code> iterations as follows.</p><pre><code class="language-julia hljs">julia&gt; KernTree = tree_approximation!(Tree([1,2,2,2],1),
kernel_scenarios(gsdata, Logistic; Markovian = false), 100000, 2, 2);
julia&gt; tree_plot(KernTree)</code></pre><p>The following figure shows the resultant scenario tree. The algorithm returns the multistage distance of the scenario lattice as <code>dist = 0.2753</code>.</p><p><img src="../../assets/kerneltree.png" alt="Scenario Tree From Kernel Trajectories"/></p><p>This method is very efficient when you have limited data. This data may not be enough to generate a scenario tree or a scenario lattice. In case of limited data it is necessary to learn as much as possible from the observations available. Therefore generating scenarios using the above procedure proves to be important.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial4/">« Stochastic approximation process</a><a class="docs-footer-nextpage" href="../tutorial5/">Performance of <code>ScenTrees.jl</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Friday 13 May 2022 09:46">Friday 13 May 2022</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
