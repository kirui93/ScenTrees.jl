<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ScenTrees.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ScenTrees.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ScenTrees.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Goal-of-ScenTrees.jl"><span>Goal of <code>ScenTrees.jl</code></span></a></li><li><a class="tocitem" href="#Description-of-a-scenario-tree"><span>Description of a scenario tree</span></a></li><li><a class="tocitem" href="#Description-of-a-scenario-lattice"><span>Description of a scenario lattice</span></a></li><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li></ul></li><li><a class="tocitem" href="../tutorial2/">Scenario Trees</a></li><li><a class="tocitem" href="../tutorial3/">Scenario Lattices</a></li><li><a class="tocitem" href="../tutorial31/">Stochastic processes</a></li><li><a class="tocitem" href="../tutorial4/">Stochastic approximation process</a></li><li><a class="tocitem" href="../tutorial41/">Kernel Density Estimation</a></li><li><a class="tocitem" href="../tutorial5/">Performance of <code>ScenTrees.jl</code></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kirui93/ScenTrees.jl/blob/master/docs/src/tutorial/tutorial1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>A stochastic program is a mathematical program that involves some uncertain data. These parameters may be mostly accurately described by random variables. In most cases, it is difficult to optimize directly in terms of the distributions of these random variables. Hence, in most cases, these distributions are approximated by discrete distributions with a finite number of scenarios for the random variables. This discretization procedure is what is often called <code>scenario generation</code>. Uncertainty in long-term capacity planning is inescapable. The random parameters can be conceived to follow a multistage stochastic process over some time space so that the discrete scenarios represent sample paths. The approach we take is to form an approximation of the original stochastic process by discretization.</p><p>In multistage stochastic optimization, we are interested in approximations of stochastic processes by finite structures. These processes are random and they have uncertain scenarios and a decision maker needs to make decisions at different stages of the process. It is useful to depict the possible sequences of data for this processes in form of a <code>scenario tree</code> in the case of a discrete time stochastic process and a <code>scenario lattice</code> for Markovian data processes.</p><p>A scenario tree is a set of nodes and branches used in models of decision making under uncertainty. Every node in the tree represents a possible state of the world at a particular point in time and a position where a decision can be made. Each tree node has a single predecessor and multiple successors whereas a lattice can have many predecessor.</p><p>A scenario tree/lattice is organized in levels which corresponds to stages <span>$1,\ldots,T$</span>. Each node in a stage has a specified number of predecessors as defined by the branching structure. A node represents a possible state of the stochastic process and the vertices represents the possibility of transition between the two connected nodes. A scenario tree differs from a scenario lattice by the condition that each node in stage <span>$t$</span> must have one predecessor in stage <span>$t-1$</span>. For a lattice, that is not the case; all the nodes in stage <span>$t-1$</span> share the same children in stage <span>$t$</span>.</p><h2 id="Goal-of-ScenTrees.jl"><a class="docs-heading-anchor" href="#Goal-of-ScenTrees.jl">Goal of <code>ScenTrees.jl</code></a><a id="Goal-of-ScenTrees.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Goal-of-ScenTrees.jl" title="Permalink"></a></h2><p>We model stochastic processes by scenario trees and scenario lattices. The distributions of these processes may be continuous and involves parameters that are uncertain.</p><p>The goal  of <code>ScenTrees.jl</code> is to approximate the distributions of these stochastic processes by discrete distributions with finite number of scenarios of the random variables. We generate a valuated probability scenario tree or a scenario lattice which represents the stochastic process in the best way possible using the stochastic approximation algorithm. These processes are random and represent uncertainty at a particular state and at a certain point in time.  </p><p>These approximations should be tractable, which is small enough to allow for reasonable calculation times, but is large enough to capture the important features of the problem. We use the concept of multistage distance to determine the quality of the approximations</p><h3 id="Introductory-example"><a class="docs-heading-anchor" href="#Introductory-example">Introductory example</a><a id="Introductory-example-1"></a><a class="docs-heading-anchor-permalink" href="#Introductory-example" title="Permalink"></a></h3><p>Consider a simple Gaussian random walk in 5 stages. The starting value of this process is known and fixed, say at <span>$0$</span> and the other values are random. The following plot shows 100 sample paths of this process:</p><p><img src="../../assets/100GaussianPaths.png" alt="100 sample paths from Gaussian random walk"/></p><p>We generate and improve a scenario tree or a scenario lattice using this stochastic process. The number of iterations for the algorithm equals the number of sample paths that we want to generate from the stochastic process. Also, the number of stages in the stochastic process equals the number of stages in the scenario tree or the scenario lattice.</p><p>The user is free to choose any branching structure for the scenario tree/lattice. The branching structure shows how many branches each node in the tree has at each stage of the tree. For example, we can use a branching structure of <span>$1x2x2x2x2$</span> for the scenario tree. This means that each node in the tree has two children. Basically, this is a <code>binary tree</code>. It has been shown that the elements in the branching structure have a direct relationship with the quality of the resulting scenario tree/lattice. A scenario tree/lattice with many branches has a better approximation quality than a scenario tree with less branches.</p><p>Using the binary branching structure stated above, we obtain the following valuated probability tree that represents the above stochastic process:</p><p><img src="../../assets/TreeExample.png" alt="Scenario Tree 1x2x2x2x2"/></p><p><em>Figure 1: Scenario Tree 1x2x2x2x2</em></p><p>The above tree is optimal and therefore can be used by a decision maker for a decision making process depending on the type of problem he/she is handling. To measure the quality of this approximation, we use the concept of multistage distance between the stochastic process and the scenario tree or lattice, which we introduce in the following subsection.</p><h3 id="Multistage-distance"><a class="docs-heading-anchor" href="#Multistage-distance">Multistage distance</a><a id="Multistage-distance-1"></a><a class="docs-heading-anchor-permalink" href="#Multistage-distance" title="Permalink"></a></h3><p>To measure the distance of stochastic processes, it is not sufficient to only consider the distance between their laws. It is also important to consider the information accumulated over time i.e., what the filtration has to tell us over time. The Wasserstein distance do not correctly separate stochastic processes having different filtration. It ignores filtration and hence does not distinguish stochastic processes. Multistage distance comes in handy in the situations for measuring distances for stochastic processes. Multistage distance is also called the <code>process distance</code> or <code>nested distance</code>.</p><p>Multistage distance was introduced by <a href="https://doi.org/10.1137/080718401">Georg Ch. Pflug (2009)</a>. It turns out that this distance is very important to measure the distance between multistage stochastic processes as it incorporates filtration introduced by the processes. We use this distance in our algorithm to measure the quality of approximation of the scenario tree and scenario lattice. Generally, a scenario tree/lattice with a minimal distance to the stochastic process is consider to have a better quality approximation.</p><p>The distance between the above scenario tree and the original process is <code>0.0894</code>. This shows that the scenario tree above approximates the stochastic process well. This tree can therefore be used for decision making under uncertainty.</p><h2 id="Description-of-a-scenario-tree"><a class="docs-heading-anchor" href="#Description-of-a-scenario-tree">Description of a scenario tree</a><a id="Description-of-a-scenario-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-a-scenario-tree" title="Permalink"></a></h2><p>A scenario tree is described by the following:</p><ol><li>Name of the tree</li><li>Parents of the nodes in the tree</li><li>Children of the parents in the tree</li><li>States of the nodes in the tree</li><li>Probabilities of transition from one node to another.</li></ol><p>A scenario tree is a mutable struct of type <code>Tree()</code>. To create a non-optimal scenario tree, we need to fix the branching structure and the dimension of the states of nodes you are working on. The type <code>Tree()</code> has different methods:</p><pre><code class="language-julia hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;ScenTrees&quot;)
julia&gt; using ScenTrees
julia&gt; methods(Tree)
# 4 methods for generic function &quot;(::Type)&quot;:
[1] Tree(name::String, parent::Array{Int64,1},
children::Array{Array{Int64,1},1}, state::Array{Float64,2}, probability::Array{Float64,2})
[2] Tree(identifier::Int64)
[3] Tree(spec::Array{Int64,1})
[4] Tree(spec::Array{Int64,1}, dimension)</code></pre><p>All the methods correspond to the way you can create a scenario tree. For the first method, the length of states must be equal to the length of the probabilities. In the 2nd method, you can call any of our predefined trees by just calling on the identifier (these identifiers are <code>0, 301, 302, 303, 304, 305, 306, 307, 401, 402, 4022, 404, 405</code>). And finally the most important methods are the 3rd and 4th method. If you know the branching structure of your scenario tree, then you can create an non-optimal starting tree using it. If you don&#39;t state the dimension you are working on, then it is defaulted into <code>1</code>. For example, <code>Tree([1,2,2,2,2])</code> creates a binary tree with states of dimension one as in Figure 1 above</p><h2 id="Description-of-a-scenario-lattice"><a class="docs-heading-anchor" href="#Description-of-a-scenario-lattice">Description of a scenario lattice</a><a id="Description-of-a-scenario-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-a-scenario-lattice" title="Permalink"></a></h2><p>A scenario lattice differs from a scenario tree in that every node in stage <code>t</code> is a child for each node in stage <code>t-1</code>. So the nodes in stage <code>t-1</code> share the same children.</p><p>Due to the above, we only describe a scenario lattice by:</p><ol><li>Name of the lattice</li><li>States of the nodes of the lattice</li><li>Probabilities of transition from one node to another in the lattice</li></ol><p>A scenario lattice has only one method.</p><pre><code class="language-julia hljs">julia&gt; methods(Lattice)
 1 method for generic function &quot;(::Type)&quot;:
[1] Lattice(name::String, state::Array{Array{Float64,2},1},
probability::Array{Array{Float64,2},1})</code></pre><p>This method is not very important because we only need it to produce the results of the lattice approximation process. We will see later that for lattice approximation, we need the branching structure and so the structure of the lattice is not very important as in the case of a scenario tree.</p><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><p>Since we have the basics of the scenario tree and the scenario lattice and since we created <code>ScenTrees.jl</code> with an intention of being user-friendly, we present the exported functions that are visible to the user i.e., that are public, and the user can call these functions depending on what he/she wants to achieve with this package:</p><ol><li>Tree (associated are: nodes, stage, height, leaves, root, part<em>tree, build</em>probabilities!),</li><li>tree_approximation!</li><li>Lattice,</li><li>lattice_approximation,</li><li>kernel_scenarios (for conditional density estimation method)</li><li>Plotting utilities (these functions include: tree<em>plot, plot</em>hd and plot_lattice),</li><li>Examples of process functions (gaussian<em>path1D, gaussian</em>path2D, running<em>maximum1D, running</em>maximum2D, path) and,</li><li>bushiness_nesdistance (returns a graph showing how different factors affects the multistage distance.)</li></ol><ul><li><p>The most important functions in this module are <code>tree_approximation!()</code> and <code>lattice_approximation()</code> since these are the two functions which are used to approximate scenario trees and scenario lattices respectively.</p></li><li><p>The other important function is the <code>Tree(bstructure, dimension)</code> function which gives the basic starting structure of a scenario tree.</p></li></ul><h3 id="Querying-the-documentation-of-each-function"><a class="docs-heading-anchor" href="#Querying-the-documentation-of-each-function">Querying the documentation of each function</a><a id="Querying-the-documentation-of-each-function-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-the-documentation-of-each-function" title="Permalink"></a></h3><p>All of the above functions have been documented in their respective scripts and the user can find out what each function does by putting a <code>?</code> before the function. For example, <code>?leaves</code> will give an explanation of what the function <code>leaves</code> does.</p><p>In the upcoming tutorials, we will have a look in detail on what each function of this package does.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../tutorial2/">Scenario Trees »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Friday 13 May 2022 11:57">Friday 13 May 2022</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
