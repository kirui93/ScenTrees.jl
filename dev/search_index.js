var documenterSearchIndex = {"docs":
[{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial5/#Performance-of-ScenTrees.jl","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"","category":"section"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"ScenTrees.jl was built with a goal of employing the speed of Julia. This package's design allows us to obtain a fast code with high flexibility and excellent computational efficiency. The design choices are highly motivated by the properties of the Julia language.","category":"page"},{"location":"tutorial/tutorial5/#Computational-time-for-trees-of-different-heights","page":"Performance of ScenTrees.jl","title":"Computational time for trees of different heights","text":"","category":"section"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"It is important to note that a scenario tree converges in probability for more and more samples that you generated to improve the tree, i.e., if you perform more iterations then you will get a scenario tree that has a better approximation quality than when you perform less iterations.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"One other thing that comes into play for the approximation quality of the scenario tree is the bushiness of the tree. It turns out that having a bushy branching structure produces a scenario tree that has a better approximation quality than a tree with less bushy branching structure. Also, the height of the tree plays a big role on the approximation quality of the scenario tree. Higher trees have a better approximation quality than shorter trees. If we combine these two factors (bushiness and height of the tree), we get a tree which has the best approximation quality of the stochastic process in consideration. The multistage distance converges to 0 as the bushiness of the scenario tree increases. The convergence of the multistage distance holds in probability.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The table below shows the multistage distance of trees of different heights with an increasing branching structure:","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Branches Height = 1 Height = 2 Height = 3 Height = 4\n3 0.24866 0.2177 0.16245 0.11346\n4 0.16805 0.12861 0.08451 0.05236\n5 0.12333 0.08559 0.05073 0.0289\n6 0.09561 0.06042 0.03345 0.01913\n7 0.07752 0.04562 0.02333 0.01188\n8 0.06401 0.03547 0.01711 0.00855","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The above table can be represented in a plot as follows:","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"(Image: Multistage distance for trees of different heights)","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The above plot can be obtained by calling the function bushiness_nesdistance() from the package.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Generally, the approximating quality of a scenario tree increases with increasing height of the tree and increasing bushiness of the tree.","category":"page"},{"location":"tutorial/tutorial5/#Comparison-with-implementation-in-MATLAB","page":"Performance of ScenTrees.jl","title":"Comparison with implementation in MATLAB","text":"","category":"section"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"In order to see how fast Julia is, we compared the run-time performance of different trees with different heights with the same algorithm written in MATLAB programming language. We run the same trees and saved the time it takes to produce results. The following table shows the results (N/B: The time shown is in seconds):","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Tree Number of Iterations Run-time (Julia) Run-time (MATLAB) Speed of Julia\n1x2x2 10,000 0.17 6.75 38.9 times\n1x2x2x2 10,000 0.16 9.74 59.8 times\n1x2x2x2 100,000 1.77 111.73 63.1 times\n1x2x4x8 100,000 2.31 184.11 79.7 times\n1x2x3x4x5 1,000,000 23.15 1955.66 84.5 times\n1x3x3x3x2 1,000,000 20.12 1652.92 82.2 times\n1x3x3x3x3 1,000,000 21.44 1752.40 81.7 times\n1x10x5x2 1,000,000 23.96 2046.88 85.4 times\n1x3x4x4x2x2 1,000,000 27.36 2211.54 80.8 times","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"What is clear is that ScenTrees.jl package outperforms MATLAB for all the scenario trees. Also, it is important to see that ScenTrees.jl performs pretty faster for scenario trees which are bushy and has different heights.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"ScenTrees totally relies on the features of Julia language. This lead us to attain a speed of approximately 80 times than MATLAB.","category":"page"},{"location":"tutorial/tutorial5/#Development-and-Testing","page":"Performance of ScenTrees.jl","title":"Development and Testing","text":"","category":"section"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"ScenTrees.jl was developed in Julia 1.0.4 and tested using the standard Julia framework. It was tested for Julia versions 1.0,1.1,1.2 and nightly for the latest release of Julia in Linux and OSX distributions.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The comparison done for this package in Julia 1.0.4 and MATLAB R2019a was done on Linux(x86_64-pc-Linux-gnu) with CPU(TM) i5-4670 CPU @ 3.40GHz.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"What is more important for testing and development is the processor speed for your machine. Machines with low processors will take longer time to execute the functions than machines with high processors. Hence, depending on the type of processor you have, you may or may not or even pass the computational speed that we achieved for this package.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"tip: Tip\nThis package is actively developed and new features and improvements are constantly and continuously added. So, before using it, make it an habit to update your packages.","category":"page"},{"location":"tutorial/tutorial5/","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"This ends our tutorials for using ScenTrees.jl. You are now ready to generate scenario trees and scenario lattices depending on what you want to approximate.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial41/#Kernel-Density-Estimation","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"","category":"section"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"This is a non-parametric technique for generating trajectories used to generate and improve scenario trees and scenario lattices in the stochastic approximation algorithm already discussed in the previous tutorials. This is a case where the distributions are not available explicitly and so the samples can be drawn from a data by proper approximations. Generating a scenario tree/lattice using trajectories from these method involves two steps:","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Conditional density estimation process, and,\nStochastic approximation process.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The stochastic approximation process has already been described in the previous tutorials. Hence, here we will concentrate on the conditional density estimation process.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The conditional density estimation step involves two steps:","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Estimation of the distribution of conditional densities, and,\nComposition method","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"We estimate the distribution of transition densities given the history of the process. This distribution is estimated by the non-parametric kernel density estimation. The density at stage t+1 conditional on the history mathbfx_t = (x_1x_2ldotsx_t) is estimated by","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"hatf_t+1(x_t+1mathbfx_t) = sum_j=1^N w_j(mathbfx_t) cdot k_h_N(x_t+1 - xi_jt+1)","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"where k() is a kernel function, h_N is the bandwidth and k_h_N is the weighted kernel function.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The weights are given by","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"w_j(mathbfx_t) = frackbig(fracx_i_1 - xi_j1h_Nbig)cdot ldots cdot kbig(fracx_i_t - xi_jth_Nbig)sum_ell=1^Nkbig(fracx_i_1 - xi_l1h_Nbig)cdot ldots cdot kbig(fracx_i_t - xi_lth_Nbig)","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Notice from above that the weights depend on the history mathbfx_t up to stage t only. Also, the weights sum up to 1 for every mathbfx_t ie sum_j=1^N w_j(mathbfx_t) = 1.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"We use the composition method to find the samples from the conditional distribution hatf_t+1(mathbfx_t) as follows. Pick a random number u in (01) where u is uniformly distributed then find a summation index j^star in 12ldotsN such that sum_j=1^j^star-1 w_j(mathbfx_t)  U leq sum_j=1^j^star w_j(mathbfx_t)","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"It has been shown that the cumulative sum of weights leads to a high probability of picking a data path near the observation.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The value of the data xi_t is obtained by setting the value at stage t to","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"xi_t = X_j^star + h_N times textrand(k())","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"where textrand(k()) is a random value sampled from the kernel estimator.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The generated data point is according to the distribution of the density at the current stage and dependent on the history of all the data points. It has been shown that the choice of the kernel does not have an important effect on density estimation. Hence, we employ the following logistic kernel as default: k(x) = frac1(e^x + e^-x)^2","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"One of the most important factor to consider in density estimation is the bandwidth. We use the Silverman's rule of thumb to obtain the bandwidths for each of the data columns as follows h_N = sigma(X_t)cdot N^frac-1d+4 where d is dimension of values sitting on each node at stage t and sigma(X_t) is the standard deviation of data in stage t.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Using the above procedure, every new sample path starts with x_1 at the first stage. Using the composition method, we find a new sample x_2 from hatf_2(x_1) at the second stage. Next, we generate a new data point x_3 from hatf_3(x_12)  at the third stage, a new sample x_t from hatf_t(x_1t-1) at stage t e.t.c. Iterating the procedure until the stage T reveals a new sample path x = (x_1x_2ldotsx_T), generated from the initial data xi_1ldotsxi_N directly.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The new sample path x is what we will feed in the stochastic approximation algorithm to generate either a scenario tree or a scenario lattice.","category":"page"},{"location":"tutorial/tutorial41/#Implementation-of-the-above-process","page":"Kernel Density Estimation","title":"Implementation of the above process","text":"","category":"section"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"We use the concept of function closures to implement the above process. The motive to use function closures is because we want to follow the guidelines of the package where the process function should be coded in such a way that it doesn't take any inputs. We assume that the user of this package is conversant with function closures. The user is required to provide a data in 2 dimension, i.e., a matrix of Float64 or Int64, to this function and also the distribution of the kernel that he/she wants to use. The default kernel distribution is the Logistic kernel. The kernel distribution should conform to the distributions stated in Distributions.jl package.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Most of the times when you load the data into Julia, it loads it as a DataFrame type. But we have wrote the function in a manner that the user should provide a Matrix of either floats or integers. In the following procedure, we use the function Matrix to convert the loaded dataframe into a matrix which is the right type of input into the function.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The function kernel_scenarios(data::Union{Array{Int64,2},Array{Float64,2}}, kernelDistribution = Logistic; Markovian = true) takes a (N times T) dimensional data and the distribution of the kernel you want to employ. The N rows of the data are the number of trajectories in the initial data and the T columns is the number of stages in in each trajectory of the data. We also let the user to specify whether the process he/she is creating is a Markovian process or not. We are aware that scenario lattices are natural discretization of Markovian process. Hence the user should create samples for a scenario tree for the condition Markovian = false and scenario lattices for the condition Markovian = true.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Since tree_approximation! and lattice_approximation function needs a process function for generating samples that doesn't take any inputs, we employ the concept of function closures inside the above function. The function kernel_scenarios(data, kernelDistribution; Markovian = true) is a get-field type of a function closure and so is sufficient to be a function required for stochastic approximation process.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"To confirm the above statement, consider a 1000 times 5 dimensional data from random walk. What is important to be said is that we use the package CSV.jl to read the data into Julia and since we need the data in matrix form, we use the function Matrix from the package DataFrames.jl to convert the dataframe into an array in two dimension which is then the input of our function.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"julia> using ScenTrees, CSV, Distributions\njulia> data = CSV.read(\".../RandomDataWalk.csv\")\njulia> Rdw = Matrix(data)\njulia> Kdt = kernel_scenarios(Rwd,Logistic;Markovian=true)\n(::getfield(ScenTrees,Symbol(\"#closure#52\")){Array{Float64,2},\nInt64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1}})\n(generic function with 1 method)\njulia> ExampleTraj = kernel_scenarios(Rwd, Logistic; Markovian = true)()\n[2.9313, -2.0964, 3.7671, 2.1476, 0.9424]","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"As in ExampleTraj above, this function returns is a new sample according to the distribution of the density at the current stage and dependent on the history of all the data points.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"We use the above data to approximate a scenario lattice in 5 stages with a branching structure of (1times 3times 4times 5times6)  and 100000 number of iterations as follows:","category":"page"},{"location":"tutorial/tutorial41/#Approximating-with-a-scenario-lattice","page":"Kernel Density Estimation","title":"Approximating with a scenario lattice","text":"","category":"section"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Using the above data, the conditional density estimation method and lattice approximation process we can generate a scenario lattice with a branching structure [1,3,4,5,6] and 100,000 iterations as follows.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"julia> KernExample = lattice_approximation([1,3,4,5,6],\nkernel_scenarios(Rwd, Logistic; Markovian = true), 100000, 2, 1);\njulia> plot_lattice(KernExample)","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The following is the resultant lattice from the above approximation. The algorithm returns the multistage distance of the scenario lattice as dist = 1.1718.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"(Image: Scenario Lattice From Kernel Trajectories)","category":"page"},{"location":"tutorial/tutorial41/#Approximating-with-a-scenario-tree","page":"Kernel Density Estimation","title":"Approximating with a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"Using the same procedure, we can generate a binary scenario tree with 100,000 iterations as follows.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"julia> KernTree = tree_approximation!(Tree([1,2,2,2],1),\nkernel_scenarios(gsdata, Logistic; Markovian = false), 100000, 2, 2);\njulia> tree_plot(KernTree)","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"The following figure shows the resultant scenario tree. The algorithm returns the multistage distance of the scenario lattice as dist = 0.2753.","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"(Image: Scenario Tree From Kernel Trajectories)","category":"page"},{"location":"tutorial/tutorial41/","page":"Kernel Density Estimation","title":"Kernel Density Estimation","text":"This method is very efficient when you have limited data. This data may not be enough to generate a scenario tree or a scenario lattice. In case of limited data it is necessary to learn as much as possible from the observations available. Therefore generating scenarios using the above procedure proves to be important.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial31/#Stochastic-processes","page":"Stochastic processes","title":"Stochastic processes","text":"","category":"section"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"A stochastic process is a sequence of events in which the outcome of any stage depends on some probability. A stochastic process is also called a random process.The stochastic process is said to be continuous, if i.e. with probability one, all of its trajectories are continuous functions in t.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"There are many ways in which the stochastic processes can be classified. For example, they can be classified in terms of boundedness, continuity etc., i.e. properties of their sample trajectories. They could also be described with respect to the properties of their distribution functions. However, we find it important to classify the stochastic processes according to their memory. We classify these processes as discrete time stochastic processes and Markovian data processes. The Markov processes are processes with short memory where the process has memory only at its immediate past. With this in mind, in our stochastic approximation process, we approximate a discrete time stochastic process with a scenario tree and a Markovian data process with a scenario lattice.  ","category":"page"},{"location":"tutorial/tutorial31/#Stochastic-function","page":"Stochastic processes","title":"Stochastic function","text":"","category":"section"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"This is a user-defined function representing the stochastic process in which she/he wants to approximate. This is the function that will generate trajectories that helps to improve the states of the nodes in the scenario tree or scenario lattice. To be able to do a good approximation, the user of this package should be aware of the number of stages in the scenario tree or scenario lattice that she/he is working on and more importantly, the dimension of the states of nodes in the tree or the scenario lattice. Why is this important? For each iteration, the stochastic approximation algorithm generates one trajectory from the stochastic function that will improve one path in the scenario tree. Therefore, knowing the number of stages and the dimension of the states will help the user to design a stochastic function that generates a trajectory with the same length as the number of stages in the scenario tree and with the same dimension as the dimension of the states in the scenario tree.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"We have the following examples in our package:","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"Gaussian random walk,\nRunning Maximum process, and,\nSample Gaussian stock paths","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"We have created the first two example functions in 1 and 2 dimensions. What we mean by dimension is that, a function in 1 dimension generates just one array. Generally, a function in d-dimension generates d arrays. As stated before, the length of the array and the dimension of the array naturally depends on the characteristics of the scenario tree or scenario lattice that you are using.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"The position X_t of a Gaussian random walk after t steps is","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"X_t = sum_k=1^t Y_k","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"where the random variables (Y_k)_kgeq 1 are independent and identically distributed and each Y_k follows a normal distribution. For the running maximum process, we take the maximum of each two consecutive numbers in a sample drawn from a normal distribution. Mathematically,","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"M_t = max sum_t=1^t^prime xi_t  t^prime leq t  textwith  xi_t sim N(01)","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"We insist that the user of this package must write a function that takes no inputs. This function should be, in a way, a hard-coded function that when you call, it produces an array with a certain user pre-determined characteristics.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"The above two processes in our package are in 4 stages and therefore can be used with a scenario tree or a scenario lattice with 4 stages. As already stated, the stages in a scenario tree or a scenario lattice starts from 1 to T. Each of these processes generates samples with a common starting point since a stochastic process has a deterministic starting value and the rest of the values are random.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"It is important to create a function that generates samples that are dependent on each other in d dimension. Most stochastic processes have states which depends on each other and so it is always important to consider dependency of the samples generated by the stochastic function.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"The following shows sample trajectories of our example functions above:","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"julia> gaussian_path1D() # 4 stages, 1 dimension\n[0.0, -0.1566, -1.5676, -1.2084]\n\njulia> gaussian_path1D()\n# 2nd run - same starting value, different other values (randomness)\n[0.0, -2.1779, -2.4299, -1.3796]\n\njulia> gaussian_path2D() # 4 stages, 2 dimension\n[1.0, 0.6968, 2.2257, 3.3988 ; 0.0, -0.3676, -0.1558, -0.2629]\n\njulia> running_maximum1D()\n[0.0, 0.0, 0.5574, 0.9278]\n\njulia> running_maximum2D()\n[0.0, 2.7430, 2.3931, -0.7218; 0.0, 0.4331, 0.4331, 0.3281]\n\njulia> path() # example of stock prices\n[100.0, 78.7084, 109.4443, 74.3815]","category":"page"},{"location":"tutorial/tutorial31/#Notes","page":"Stochastic processes","title":"Notes","text":"","category":"section"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"The user of this package must provide this function.\nThe function must take no inputs. This is so important for the stochastic approximation algorithm.\nThe length of an array produced by the function must be equal to the number of stages in the scenario tree or the scenario lattice.\nThe dimension of the array produced must be the same as the dimension of the states of the scenario tree or scenario lattice.\nThe array should have a common deterministic starting point or be in a certain range of values.\nThe array produced should be a N x d Array{Float64,2} where N is the number of stages and d is the dimension. This is important for the stochastic approximation process.\nIn higher dimension, depending on the user, the arrays could be dependent on each other.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"Up to this point, the user can now create a random scenario tree and look at its characteristics as well as write a process function that generates trajectories for the stochastic approximation process. It is important to write a function that follows the above criterion as this becomes very important in the stochastic approximation process.","category":"page"},{"location":"tutorial/tutorial31/","page":"Stochastic processes","title":"Stochastic processes","text":"Having looked on the scenario trees, scenario lattices and stochastic processes, we are now ready to have a look on the stochastic approximation process. This is in our next tutorial.","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial3/#Scenario-Lattices","page":"Scenario Lattices","title":"Scenario Lattices","text":"","category":"section"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"If the data process is Markovian, we approximate the process with a scenario lattice instead of a scenario tree. Scenario lattices are natural discretizations of the Markov processes.","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"A scenario lattice is similar to a scenario tree but has an added requirement that all nodes in stage t have the same children. This makes the description of a scenario lattice less than for a scenario tree as a scenario lattice can only be described by its name, states of the nodes in the lattice and the probabilities of transition in the lattice.","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"In a scenario lattice, the total number of nodes is equal to the total number of states which is equal to the sum of the elements in the branching vector.","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"Consider the scenario lattice below with branching structure 1x2x3x4x5:","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"julia> ExampleLattice = lattice_approximation([1,2,3,4,5],gaussian_path1D,1000000,2,1);\njulia> plot_lattice(ExampleLattice)","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"(Image: Example of a scenario lattice)","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"In the above scenario lattice, the total number of nodes are 1+2+3+4+5 = 15 nodes and the total number of edges in the lattice are (1 times 2)+(2 times 3)+(3 times 4)+(4 times 5) = 40 edges. A scenario tree with the same branching structure has 153 nodes and 153 links. This shows that, in a lattice, the number of variables do not grow exponentially as it does in a scenario tree. However, the number of possible paths in a scenario lattice is larger than in a scenario tree.","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"Some of the characteristics of a scenario lattice are:","category":"page"},{"location":"tutorial/tutorial3/","page":"Scenario Lattices","title":"Scenario Lattices","text":"You will notice that a states and the probabilities of the lattice are of type Array{Array{Float64,2},1}. This is because of the fact that the nodes of the lattice can have multiple predecessors.\nThe number of states in the scenario lattice is equal to the number of nodes. The number of nodes is given by the sum of elements in the branching vector.\nScenario lattices are used for Markovian processes; which are memory-less processes. Therefore, the number of probabilities to reach one node is equal to the number of predecessors of that node.\nThe sum of all probabilities in each stage equals to one.\nJust like in a scenario tree, a scenario lattice has one root node. Each node in the lattice has multiple predecessors except the root node.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial4/#Stochastic-approximation-process","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"","category":"section"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"This package follows the stochastic approximation procedure and theory in Pflug and Pichler (2015). Given a stochastic process, we want to approximate the process using either a scenario tree or a scenario lattice.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Every stochastic approximation iteration modifies one path within the tree towards the new sequence. In this way the approximating quality of the tree is improved each time a new sample is observed. The tree is not stable in the beginning but with more and more iterations, the scenario tree converges in probability. The resulting tree can be used for decision making process.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The stochastic approximation process is outlined as follows:","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Decide on the branching structure of the tree/ lattice,\nStart with a tree/lattice (which is more of a qualified guess) with the stated branching structure,\nGenerate one sample from a particular known distribution with the same length and dimension as the states of the nodes of the tree/lattice.\nThe algorithm finds a sequence of nodes in the tree where the distance between the states of those nodes and the generated sample is minimal. The algorithm then updates the states of those nodes with the values in the generated sample. The states of other nodes remains unchanged.\nAt every iteration of the algorithm, the multistage distance is calculated.\nWhen done with the states of the nodes of the tree, the algorithm calculates the conditional probabilities to reach each node in the tree. At the end, the sum of the conditional probabilities to reach each node of the same parent must add up to 1.\nThe algorithm stops when all the number of iterations have been performed.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The most important function in this approximation process is the function that user wants to approximate. This is the function that generates samples that improves the tree in each iteration. The function must be designed in a way that it doesn't take any inputs. It must be a hard-coded function in that and the length of an array that it produces must match the number of stages of the tree and the dimension of the states of the tree.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"tip: Tip\nThe branching structure of the scenario tree and the scenario lattice must start with 1. This indicates the root of the tree. It also fix the deterministic state of the tree. The rest of the values in the branching vector of the scenario tree or the scenario lattice generally depends on the user. For example, a binary tree in 4 stages would have a branching structure of [1,2,2,2].","category":"page"},{"location":"tutorial/tutorial4/#Tree-Approximation","page":"Stochastic approximation process","title":"Tree Approximation","text":"","category":"section"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"In this package, we have the function tree_approximation!(Tree(bstructure, dimension), path, nIterations, p = 2, r = 2) which does the stochastic approximation process for scenario trees. This function takes the following inputs:","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Tree (which takes the branching structure and dimension and inputs)\nName of the function that generates samples from a stochastic process you want to approximate\nNumber of iterations\nChoice d of the norm (Example: max = 0,sum = 1,Euclidean = 2(default))\nChoice r for the multistage distance (r = 2(default))","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Given the above inputs, the function does the stochastic approximation process and returns a valuated scenario tree.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"info: Info\nThe user must provide the above inputs to the function. The user also dictates where the tree starts from in the script that generates samples from a stochastic process that the user wants to approximate.","category":"page"},{"location":"tutorial/tutorial4/#Example","page":"Stochastic approximation process","title":"Example","text":"","category":"section"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Consider the following. We want to approximate the Gaussian random walk in 4 stages with a tree with a branching structure of 1x3x3x3 in 1 dimension using the usual Euclidean distance ,p=2 and r=2 for the multistage distance.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> using ScenTrees\njulia> ex2 = Tree([1,3,3,3],1)\njulia> sol1 = tree_approximation!(ex2, gaussian_path1D, 100000, 2, 2)\njulia> tree_plot(sol1)\njulia> savefig(\"treeapprox1.png\")","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The function gaussian_path1D() takes no inputs and generates one trajectory of the Gaussian random walk in 4 stages. For each iteration of the process, this process function generates a trajectory that will help improve the states of the nodes in the scenario tree.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> gaussian_path1D()   # 4 stages, 1 dimension\n[0.0, 1.49765, -0.17537, -1.2982]","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The output for the above approximation, shown below, is a scenario tree that is stable and represents the stochastic process in the best possible way.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"(Image: Example of a valuated tree in 1D)","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"We can also approximate a stochastic process in two dimension. Consider the Gaussian random walk in 2D. Our function gaussian_path2D can generate samples from the Gaussian random walk in 2 dimension, for example as follows:","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> gaussian_path2D() # 4 stages, 2 dimension\n[1.0000, 0.76636, 3.65296, 5.1779; 0.0000, -0.44216, -0.14275, -0.42350]","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"We can therefore approximate a scenario tree in 2 dimension as follows:","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> ex3 = Tree([1,3,3,3],2);\njulia> sol2 = tree_pproximation!(ex3, gaussian_path2D, 1000000, 2, 2);\njulia> trees = part_tree(sol2)\njulia> tree_plot(trees[1])\njulia> savefig(\"trees1.png\")\njulia> tree_plot(trees[2])\njulia> savefig(\"trees2.png\")","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Each of these scenario trees have a multistage distance of 0.25142 from the original stochastic process.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"(Image: Tree for state 1) (Image: Tree for state 2)\nTree for state 1 Tree for state 2","category":"page"},{"location":"tutorial/tutorial4/#Lattice-Approximation","page":"Stochastic approximation process","title":"Lattice Approximation","text":"","category":"section"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"As mentioned before, some of the process that you may want to approximate are Markovian data processes. These processes can only be approximated by a scenario lattice. All the nodes in the same stage in a lattice have the same children nodes.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"To approximate a Markovian data process, we use the function lattice_approximation(bstructure, path, nIterations, r = 2, dim = 1).","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The following are the description of the inputs of the function:","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Branching structure of the scenario lattice,\nFunction that generates samples from the stochastic process you want to approximate and,\nNumber of iterations to be performed, and,\nMultistage parameter, r ( default, r = 2)\nDimension which you are working on, dim (default, dim = 1)","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Lattice Approximation follows the same stochastic approximation process as for the scenario tree. The only difference is that, in each stage of a lattice, we find the closest lattice entry and use the sample generated to improve it. At the beginning, the lattice is not stable but with more and more iterations, the scenario lattice converges in probability and the resulting lattice can then be used for decision making process.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"All the probabilities in each stage of the lattice must sum up to 1.","category":"page"},{"location":"tutorial/tutorial4/#Example-2","page":"Stochastic approximation process","title":"Example","text":"","category":"section"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Consider the following example. We want to approximate a Gaussian random walk of 4 stages in one dimension with a scenario lattice with the branching structure of 1x3x4x5 and 1,000,000 iterations.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> sol4 = lattice_approximation([1,3,4,5], gaussian_path1D, 1000000, 2, 1);","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The result of the above approximation is a scenario lattice which represents the stochastic process in the best way. The distance between the scenario tree and the original process is 0.8388. This scenario lattice can thus be used for decision making process under uncertainty.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"Notice that the sum of probabilities of the scenario lattice at each stage is equal to 1.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> sum.(sol4.probability)\n[1.0, 1.0, 0.999999999, 1.0]","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"info: Info\nTo visualize a scenario lattice, we use the plot_lattice function.","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"julia> plot_lattice(sol4)\njulia> savefig(\"LatticeApprox.png\")","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"The above approximation gives the following output:","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"(Image: Example of an approximated lattice)","category":"page"},{"location":"tutorial/tutorial4/","page":"Stochastic approximation process","title":"Stochastic approximation process","text":"You can see that in the scenario lattice, we have many possibilities than in a scenario tree. This shows generally that scenario lattices with half the number of nodes of a scenario tree have more number of scenarios or trajectories. A scenario lattice does not allow to trace back the history of a given scenario based on its ending node as there are many possible paths at that node. This is the main reason why we consider scenario lattices for Markovian processes","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial1/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A stochastic program is a mathematical program that involves some uncertain data. These parameters may be mostly accurately described by random variables. In most cases, it is difficult to optimize directly in terms of the distributions of these random variables. Hence, in most cases, these distributions are approximated by discrete distributions with a finite number of scenarios for the random variables. This discretization procedure is what is often called scenario generation. Uncertainty in long-term capacity planning is inescapable. The random parameters can be conceived to follow a multistage stochastic process over some time space so that the discrete scenarios represent sample paths. The approach we take is to form an approximation of the original stochastic process by discretization.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"In multistage stochastic optimization, we are interested in approximations of stochastic processes by finite structures. These processes are random and they have uncertain scenarios and a decision maker needs to make decisions at different stages of the process. It is useful to depict the possible sequences of data for this processes in form of a scenario tree in the case of a discrete time stochastic process and a scenario lattice for Markovian data processes.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree is a set of nodes and branches used in models of decision making under uncertainty. Every node in the tree represents a possible state of the world at a particular point in time and a position where a decision can be made. Each tree node has a single predecessor and multiple successors whereas a lattice can have many predecessor.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree/lattice is organized in levels which corresponds to stages 1ldotsT. Each node in a stage has a specified number of predecessors as defined by the branching structure. A node represents a possible state of the stochastic process and the vertices represents the possibility of transition between the two connected nodes. A scenario tree differs from a scenario lattice by the condition that each node in stage t must have one predecessor in stage t-1. For a lattice, that is not the case; all the nodes in stage t-1 share the same children in stage t.","category":"page"},{"location":"tutorial/tutorial1/#Goal-of-ScenTrees.jl","page":"Introduction","title":"Goal of ScenTrees.jl","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"We model stochastic processes by scenario trees and scenario lattices. The distributions of these processes may be continuous and involves parameters that are uncertain.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The goal  of ScenTrees.jl is to approximate the distributions of these stochastic processes by discrete distributions with finite number of scenarios of the random variables. We generate a valuated probability scenario tree or a scenario lattice which represents the stochastic process in the best way possible using the stochastic approximation algorithm. These processes are random and represent uncertainty at a particular state and at a certain point in time.  ","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"These approximations should be tractable, which is small enough to allow for reasonable calculation times, but is large enough to capture the important features of the problem. We use the concept of multistage distance to determine the quality of the approximations","category":"page"},{"location":"tutorial/tutorial1/#Introductory-example","page":"Introduction","title":"Introductory example","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Consider a simple Gaussian random walk in 5 stages. The starting value of this process is known and fixed, say at 0 and the other values are random. The following plot shows 100 sample paths of this process:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"(Image: 100 sample paths from Gaussian random walk)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"We generate and improve a scenario tree or a scenario lattice using this stochastic process. The number of iterations for the algorithm equals the number of sample paths that we want to generate from the stochastic process. Also, the number of stages in the stochastic process equals the number of stages in the scenario tree or the scenario lattice.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The user is free to choose any branching structure for the scenario tree/lattice. The branching structure shows how many branches each node in the tree has at each stage of the tree. For example, we can use a branching structure of 1x2x2x2x2 for the scenario tree. This means that each node in the tree has two children. Basically, this is a binary tree. It has been shown that the elements in the branching structure have a direct relationship with the quality of the resulting scenario tree/lattice. A scenario tree/lattice with many branches has a better approximation quality than a scenario tree with less branches.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Using the binary branching structure stated above, we obtain the following valuated probability tree that represents the above stochastic process:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"(Image: Scenario Tree 1x2x2x2x2)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Figure 1: Scenario Tree 1x2x2x2x2","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The above tree is optimal and therefore can be used by a decision maker for a decision making process depending on the type of problem he/she is handling. To measure the quality of this approximation, we use the concept of multistage distance between the stochastic process and the scenario tree or lattice, which we introduce in the following subsection.","category":"page"},{"location":"tutorial/tutorial1/#Multistage-distance","page":"Introduction","title":"Multistage distance","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"To measure the distance of stochastic processes, it is not sufficient to only consider the distance between their laws. It is also important to consider the information accumulated over time i.e., what the filtration has to tell us over time. The Wasserstein distance do not correctly separate stochastic processes having different filtration. It ignores filtration and hence does not distinguish stochastic processes. Multistage distance comes in handy in the situations for measuring distances for stochastic processes. Multistage distance is also called the process distance or nested distance.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Multistage distance was introduced by Georg Ch. Pflug (2009). It turns out that this distance is very important to measure the distance between multistage stochastic processes as it incorporates filtration introduced by the processes. We use this distance in our algorithm to measure the quality of approximation of the scenario tree and scenario lattice. Generally, a scenario tree/lattice with a minimal distance to the stochastic process is consider to have a better quality approximation.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The distance between the above scenario tree and the original process is 0.0894. This shows that the scenario tree above approximates the stochastic process well. This tree can therefore be used for decision making under uncertainty.","category":"page"},{"location":"tutorial/tutorial1/#Description-of-a-scenario-tree","page":"Introduction","title":"Description of a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree is described by the following:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Name of the tree\nParents of the nodes in the tree\nChildren of the parents in the tree\nStates of the nodes in the tree\nProbabilities of transition from one node to another.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario tree is a mutable struct of type Tree(). To create a non-optimal scenario tree, we need to fix the branching structure and the dimension of the states of nodes you are working on. The type Tree() has different methods:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"ScenTrees\")\njulia> using ScenTrees\njulia> methods(Tree)\n# 4 methods for generic function \"(::Type)\":\n[1] Tree(name::String, parent::Array{Int64,1},\nchildren::Array{Array{Int64,1},1}, state::Array{Float64,2}, probability::Array{Float64,2})\n[2] Tree(identifier::Int64)\n[3] Tree(spec::Array{Int64,1})\n[4] Tree(spec::Array{Int64,1}, dimension)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"All the methods correspond to the way you can create a scenario tree. For the first method, the length of states must be equal to the length of the probabilities. In the 2nd method, you can call any of our predefined trees by just calling on the identifier (these identifiers are 0, 301, 302, 303, 304, 305, 306, 307, 401, 402, 4022, 404, 405). And finally the most important methods are the 3rd and 4th method. If you know the branching structure of your scenario tree, then you can create an non-optimal starting tree using it. If you don't state the dimension you are working on, then it is defaulted into 1. For example, Tree([1,2,2,2,2]) creates a binary tree with states of dimension one as in Figure 1 above","category":"page"},{"location":"tutorial/tutorial1/#Description-of-a-scenario-lattice","page":"Introduction","title":"Description of a scenario lattice","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario lattice differs from a scenario tree in that every node in stage t is a child for each node in stage t-1. So the nodes in stage t-1 share the same children.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Due to the above, we only describe a scenario lattice by:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Name of the lattice\nStates of the nodes of the lattice\nProbabilities of transition from one node to another in the lattice","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"A scenario lattice has only one method.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"julia> methods(Lattice)\n 1 method for generic function \"(::Type)\":\n[1] Lattice(name::String, state::Array{Array{Float64,2},1},\nprobability::Array{Array{Float64,2},1})","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"This method is not very important because we only need it to produce the results of the lattice approximation process. We will see later that for lattice approximation, we need the branching structure and so the structure of the lattice is not very important as in the case of a scenario tree.","category":"page"},{"location":"tutorial/tutorial1/#Exported-functions","page":"Introduction","title":"Exported functions","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Since we have the basics of the scenario tree and the scenario lattice and since we created ScenTrees.jl with an intention of being user-friendly, we present the exported functions that are visible to the user i.e., that are public, and the user can call these functions depending on what he/she wants to achieve with this package:","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"Tree (associated are: nodes, stage, height, leaves, root, parttree, buildprobabilities!),\ntree_approximation!\nLattice,\nlattice_approximation,\nkernel_scenarios (for conditional density estimation method)\nPlotting utilities (these functions include: treeplot, plothd and plot_lattice),\nExamples of process functions (gaussianpath1D, gaussianpath2D, runningmaximum1D, runningmaximum2D, path) and,\nbushiness_nesdistance (returns a graph showing how different factors affects the multistage distance.)","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"The most important functions in this module are tree_approximation!() and lattice_approximation() since these are the two functions which are used to approximate scenario trees and scenario lattices respectively.\nThe other important function is the Tree(bstructure, dimension) function which gives the basic starting structure of a scenario tree.","category":"page"},{"location":"tutorial/tutorial1/#Querying-the-documentation-of-each-function","page":"Introduction","title":"Querying the documentation of each function","text":"","category":"section"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"All of the above functions have been documented in their respective scripts and the user can find out what each function does by putting a ? before the function. For example, ?leaves will give an explanation of what the function leaves does.","category":"page"},{"location":"tutorial/tutorial1/","page":"Introduction","title":"Introduction","text":"In the upcoming tutorials, we will have a look in detail on what each function of this package does.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ScenTrees","category":"page"},{"location":"#ScenTrees.jl","page":"Home","title":"ScenTrees.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We present ScenTrees.jl package for generating and improving scenario trees and scenario lattices for multistage stochastic optimization problems using stochastic optimization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: See also the active fork at https://github.com/aloispichler/ScenTrees.jl.","category":"page"},{"location":"#Main-features-of-the-package","page":"Home","title":"Main features of the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide algorithms for generating and improving scenario trees and scenario lattices for multistage stochastic optimization problems using stochastic approximation. In this package, we use a fixed number of trajectories of a stochastic process to generate and improve a scenario tree or a scenario lattice. The quality of approximation between the stochastic process and the scenario tree/scenario lattice is measured using a multistage (process) distance. The multistage distance suits well to measure the distance between stochastic processes because it takes notice of the effect of evolution of the process over time (cf. Georg Ch. Pflug and Alois Pichler(2012) for more on distances for multistage stochastic optimization models and the multistage distance). The resulting scenario tree/lattice from the stochastic approximation process represents the stochastic process in the best possible way and so can be used for decision making process.\nWe also provide the user with one of the methods of generating trajectories from an array of data using conditional density estimation. This method takes two steps: First, we use the conditional density estimation to generate new but different samples based on the data given. Here we estimate the distribution of transitional densities given the history of the process via the non-parametric kernel distribution. Finally, we use the composition method to get a sample from the above distribution. The trajectory created in this process can then be used in the stochastic approximation algorithm to generate scenario trees or scenario lattices for multistage stochastic approximation. We urge the user to have a look at Georg Ch. Pflug and Alois Pichler(2016) and Georg Ch. Pflug and Alois Pichler(2015) for the mathematical theory and Seguin Sara et.al(2017) for an earlier exemplary application on an electricity data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the following tutorials, we urge the user to be quite familiar with the theory and explanation of the stochastic approximation algorithm in the paper Georg Ch. Pflug and Alois Pichler(2015).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package ScenTrees.jl can be installed in Julia REPL as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"ScenTrees\")\njulia> using ScenTrees","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you have ScenTrees.jl installed, we recommend that you have a look on the tutorials from the beginning to the end to understand on how you can use the package to generate scenario tree/lattice using stochastic approximation.","category":"page"},{"location":"#Important-functions-in-the-package","page":"Home","title":"Important functions in the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following are the most important functions that ScenTrees.jl package provides. These functions are explained in detail in the upcoming tutorials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Process function: This is a user-specified function that generates trajectories of a stochastic process that the user wants to approximate by a scenario tree or a scenario lattice. To choose whether you are going to approximate with a scenario tree or a scenario lattice depends on the type of stochastic process that you have. Scenario trees are used for discrete-time stochastic processes while scenario lattices are natural discretization of the Markovian processes. This function should return an array in 2 dimension. It should not take any inputs else the user should consider using wrappers or function closures. The array returned by this function should have a length equal to the number of stages of the scenario tree/lattice, as well should have the same dimension as the dimension of the states of nodes of the tree/lattice. The user provides this function to the stochastic approximation process. Examples of inbuilt process functions are gaussian_path1D(), gaussian_path2D(), running_maximum1D(), running_maximum2D(), path().\nTree: This provides the structure of a scenario tree. It stores all the information of a tree. These information includes the name of the tree, the parent of each node, the state of each node and the probabilities from one node to another. An initial tree can be generated by Tree([bstructure],dimension) where bstructure is a vector of the branching structure of the tree and dimension is the dimension of states of nodes in the tree, where dimension = 1 indicates that each node of the tree takes just one value.\nScenario tree approximation: It returns a valuated probability scenario tree that approximates the stochastic process in the best possible way. The function tree_approximation!(Tree([bstructure], dimension), path, nIterations, p=2, r=2) takes: A scenario tree object from the Tree() function with a certain branching structure, a function generating trajectories, number of iterations, choice p of the norm (Example: max = 0, sum = 1, Euclidean = 2 (default)), and multistage distance parameter (r = 2 (default)). The number of iterations also represents the number of trajectories from the process function that we want to improve the scenario tree. For each iteration, we perform the stochastic approximation process which modifies one path in the tree towards the new trajectory and hence the approximating quality of the tree is improved in each iteration.\nScenario lattice approximation: It is used to approximate Markovian processes. As already indicated, scenario lattices are natural discretization of Markov processes. The function lattice_approximation([bstructure], path, nIterations, r = 2, dim = 1) takes: the branching structure of the lattice, function generating trajectories from a stochastic process, the number of iterations, multistage distance parameter r (default r = 2) and the dimension dim which you are working on . The scenario lattice approximation follows the the same procedure as scenario tree approximation but here we find the closest lattice entry and use samples from the process function to improve it.\nGeneration of scenarios from data: This is a non-parametric technique for generating samples from a given limited data with unknown distribution. We use this process to generate new but different samples based of the data given using the conditional density estimation techniques. The new samples can then be used to generate scenario trees and scenario lattices. The function kernel_scenarios(data, KernelDistribution = Logistic; Markovian = true) takes: 1. A limited two dimensional data (i.e., N x T matrix where N is the number of trajectories and T is the number of stages, 2. Kernel Distribution is the distribution that you want to use for the kernels. The default distribution is Logistic distribution. The user is free to choose any distribution he/she wishes from the package Distributions.jl, and, 3. an optional keyword to determine whether the trajectories generated are Markovian or not. When you set Markovian = true, the trajectories here are Markovian and are used to approximate a scenario lattice. Similarly, if you set Markovian = false, the trajectories are non-Markovian and are to generate scenario trees.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial2/#Scenario-Trees","page":"Scenario Trees","title":"Scenario Trees","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"Consider a general stochastic process X over a discrete time space T, i.e., X = (X_1dotsX_T) where X_1 is a deterministic starting value and the rest are random values or random vectors whose probability distribution is known. A scenario tree is a discrete time and discrete state process approximating the process X. We represent the scenario tree by tildeX = (tildeX_1tildeX_T). A scenario is a path from the root node to any of the leaves in the tree. The number of stages in a scenario must be equal to the number of stages in a scenario tree which is equal to the length of the sample from the stochastic process X.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"A basic scenario tree can be created using the Tree(bstructure::Array{Int64,1}, dimension::Int64) function in the package. This function takes the branching structure of the tree and the dimension of the states that you are working on. For example, consider a tree with a branching structure of 1x2x2. This is a tree with a root in stage 1, and 2 nodes in stage 2 and each of the 2 nodes in stage two has 2 nodes in stage 3 and each node has only one state and so dimension = 1.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> example1 = Tree([1,2,2],1);\njulia> treeplot(example1);","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree basically is not optimal since we just randomly fill the states of the nodes of a tree with random values. This is an example of a scenario tree to begin with in stochastic approximation process. We start with a tree like this and then we use samples from a known distribution to improve the tree for a certain specified number of iterations as we shall see in the tutorials to follow.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Non optimal tree in 1D)","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree is in 1-state dimension.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The following shows the procedure to plot trees in 2 or higher dimension. We will employ the use of the function part_tree() which partitions the main tree into sub-trees of different states. For example, if the main tree is in 2 dimension, this function will return an array with two trees where the only difference is the states of the nodes of the trees. Then, we can plot each of this trees and display. Alternatively, you can use the function plot_hd which plots the trees in any dimension without partition.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> example2 = Tree([1,2,2], 2);\njulia> example2Trees = part_tree(example2);\njulia> tree_plot(example2Trees[1])\njulia> savefig(\"example21.png\")\njulia> tree_plot(example2Trees[2])\njulia> savefig(\"example21.png\")","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Tree of state 1 ) (Image: Tree of state 2)\nTree of state 1 Tree of state 2","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"And in general, we can generate a tree in any d state dimension.","category":"page"},{"location":"tutorial/tutorial2/#Functions-describing-a-scenario-tree","page":"Scenario Trees","title":"Functions describing a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree can described by the following functions: nodes, stages, height, leaves and the root of the tree.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"Each tree has stages starting from 1 where the root node is.","category":"page"},{"location":"tutorial/tutorial2/#Nodes-of-the-tree","page":"Scenario Trees","title":"Nodes of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"This are the vertices that are in the scenario tree. Each node in the tree has a parent node except the root node where the tree starts from. As stated before, each scenario tree is characterized by its name, parents of the nodes , children of each parent nodes e.t.c. So therefore, we have nodes which has parents and those nodes are the children of the parent nodes.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"For example,","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> nodes(example1)\n1:7","category":"page"},{"location":"tutorial/tutorial2/#Stages-of-the-tree","page":"Scenario Trees","title":"Stages of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"Each node in a tree is in a specific stage and nodes in the same stage have the same number of children. The stages in a tree starts from 0 where the root node is and ends at stage T where the leaf nodes are.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> stage(example1)\n0\n1\n1\n2\n2\n2\n2","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The above example shows that we have 1 node in stage 0, 2 nodes in stage 1 and 4 nodes in stage 2. Totally, these scenario tree has 3 stages if you count from 1. The height of this scenario therefore is 3.","category":"page"},{"location":"tutorial/tutorial2/#Root-of-the-tree","page":"Scenario Trees","title":"Root of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The root of the tree is the node in which the tree starts from. The root of the tree has no parent; more or less, is the parent of all nodes.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> root(example1)\n1-element Array{Int64,1}\n1","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"The function root can also give us a sequence of nodes to reach a particular node of the tree. It turns out that this function will be very important in stochastic approximation as it will give us a path that we can improve with samples from a stochastic process.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"If we want a sequence of nodes to reach, for example, node 6 in the above tree, we just call out the root function as follows:","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> root(example1,6)\n3-element Array{Int64,1}\n1\n3\n6","category":"page"},{"location":"tutorial/tutorial2/#Leaves-of-the-tree","page":"Scenario Trees","title":"Leaves of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"In each tree, we have the leaves. Leaves are all those in the tree which doesn't have children nodes. They are the terminal nodes in the tree. Our function leaves returns the leaf nodes in the tree, their indexes and the conditional probabilities to reach each of the leaves from the root node. Consider the following:","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> leaves(example1)\n([4,5,6,7], 1:4, [0.2508,0.1709,0.2566,0.2508])","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"From the above, it is clear that the sum of the conditional probabilities to reach all the leaves in the tree is 1.","category":"page"},{"location":"tutorial/tutorial2/#Plotting-the-tree","page":"Scenario Trees","title":"Plotting the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"One of the most important things in programming is visualization. In this package, we can plot a scenario tree in 1D with the tree_plot function and with the plot_hd function for a scenario tree in D dimension.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"info: Info\nYou need to install the PyPlot.jl package for this plots.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"warning: Warning\nMatplotlib is required at the moment so that you can be able to do the plots. In the future, we are thinking of changing into a lighter back-end for plots.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"For example, we can plot a default tree already in the package and then the figure can be saved with the function savefig(). These trees can be accessed through an identifier which is just a number. These identifiers are 0, 301, 302, 303, 304, 305, 306, 307, 401, 402, 4022, 404, 405. Therefore, for these examples, you can just access them through their identifier. For example, Tree(402) returns tree with the identifier 402 in our examples. You can have a look at these trees and plot them just to get a glimpse on how scenario trees are and then you can also have a look at their characteristics as explained in the above example.","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> tree_plot(Tree(402));\njulia> savefig(\"Tree402.png\");","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Example of a tree in 1D)","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"We can plot a tree in 2 dimension as follows:","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"julia> pt = part_tree(Tree4022));\njulia> tree_plot(pt[1])\njulia> savefig(\"Tree40221.png\")\njulia> tree_plot(pt[2])\njulia> savefig(\"Tree40222.png\")","category":"page"},{"location":"tutorial/tutorial2/","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Tree of state 1 ) (Image: Tree of state 2)\nPredefined tree of state 1 Predefined tree of state 2","category":"page"}]
}
